## 331. 验证二叉树的前序序列化

序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 `#`。

         _9_
        /   \
       3     2
      / \   / \
     4   1  #  6
    / \ / \   / \
例如，上面的二叉树可以被序列化为字符串 `"9,3,4,#,#,1,#,#,2,#,6,#,#"`，其中 `#` 代表一个空节点。

给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。

每个以逗号分隔的字符或为一个整数或为一个表示 `null` 指针的 `'#'` 。

你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 `"1,,3"` 。

**示例 1:**

```
输入: "9,3,4,#,#,1,#,#,2,#,6,#,#"
输出: true
```

**示例 2:**

```
输入: "1,#"
输出: false
```

**示例 3:**

```
输入: "9,#,#,1"
输出: false
```





### 题解：

这道题依旧可以用栈来解决。

**步骤如下：**

- 首先建立一个栈q，预先向栈中push一个`1`，表示当前可以插入一个数字。
- 对接下来的输入，如果遇到`，`，则跳过。
- 遇到`#`则栈顶值减1，如果减1后变为0，则pop。
- 遇到数字则栈顶值减1，如果减1后变为0，则pop，接着push一个2进来，表示一个二叉树结点下面可以接两个结点。
- 在遇到数字的部分需要注意，数字可能不像示例里面一样都是一个数字，所以我们需要把完整的数字处理完，再进行后续操作。

**执行结果如下：**

![image-20210312134946409](E:\Github\Leetcode-\2021_03_12\image-20210312134946409.png)